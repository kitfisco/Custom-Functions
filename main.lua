local a=loadstring(game:HttpGet("https://raw.githubusercontent.com/kitfisco/Custom-Functions/main/Connection.lua"))()local b={}setreadonly(Instance,false)do local c=Instance.new;Instance.new=function(d,e)local f=c(d)if e and type(e)=="table"then for g,h in pairs(e)do f[g]=h end end;return f end end;setreadonly(Instance,true)function disconnect(i)if i then i:Disconnect()i=nil end end;b.GetChildrenWhichAre=function(self,j,k,l)local m={}local n;if k then n=self:GetDescendants()else n=self:GetChildren()end;if n and#n>0 then for o,p in pairs(n)do if p:IsA(j)then if l then return p end;table.insert(m,p)end end end;return m end;b.GetChildrenOfClass=function(self,j,k,l)local m={}local n;if k then n=self:GetDescendants()else n=self:GetChildren()end;if n and#n>0 then for o,p in pairs(n)do if p.ClassName==j then if l then return p end;table.insert(m,p)end end end;return m end;b.GetDescendantsWhichAre=function(self,j)return b.GetChildrenWhichAre(self,j,true)end;b.GetDescendantsOfClass=function(self,j)return b.GetChildrenOfClass(self,j,true)end;b.WaitForChildWhichIsA=function(self,j,q,k)local m=b.GetChildrenWhichAre(self,j,k,true)local r=a.new()if not m then local s;coroutine.wrap(function()wait(q or 5)if q then r:Invoke()else warn("Infinite yield possible on \""..self:GetFullName()..":WaitForChildWhichIsA(\""..j.."\")\"")end end)()local function t(p)if p:IsA(j)then m=p;r:Invoke()end end;if k then s=self.DescendantAdded:Connect(t)else s=self.ChildAdded:Connect(t)end;r.Invoked:Wait()disconnect(s)end;return m end;b.WaitForChildOfClass=function(self,j,q,k)local m=b.GetChildrenOfClass(self,j,k,true)local r=a.new()if not m then local s;coroutine.wrap(function()wait(q or 5)if q then r:Invoke()else warn("Infinite yield possible on \""..self:GetFullName()..":WaitForChildWhichIsA(\""..j.."\")\"")end end)()local function t(p)if p.ClassName==j then m=p;r:Invoke()end end;if k then s=self.DescendantAdded:Connect(t)else s=self.ChildAdded:Connect(t)end;r.Invoked:Wait()disconnect(s)end;return m end;b.WaitForDescendantWhichIsA=function(self,u,q)return b.WaitForChildWhichIsA(self,u,q,true)end;b.WaitForDescendantOfClass=function(self,u,q)return b.WaitForChildOfClass(self,u,q,true)end;b.WaitForAncestorWhichIsA=function(...)return b.WaitForDescendantWhichIsA(...)end;b.WaitForAncestorOfClass=function(...)return b.WaitForDescendantOfClass(...)end;b.WaitForDescendant=function(self,u,q)local m=self:FindFirstChild(u,true)local r=a.new()if not m then local s;coroutine.wrap(function()wait(q or 5)if q then r:Invoke()else warn("Infinite yield possible on \""..self:GetFullName()..":WaitForDescendant(\""..u.."\")\"")end end)()local function t(p)if p.Name==u then m=p;r:Invoke()end end;s=self.DescendantAdded:Connect(t)r.Invoked:Wait()disconnect(s)end;return m end;b.WaitForAncestor=function(...)return b.WaitForDescendant(...)end;b.GetChildrenWithName=function(self,u,k)local m={}local n;if k then n=self:GetDescendants()else n=self:GetChildren()end;if n and#n>0 then for o,p in pairs(n)do if p and p.Name==u then table.insert(m,p)end end end;return m end;b.GetDescendantWithName=function(self,u)return b.GetChildrenWithName(self,u,true)end;b.FindNextChild=function(self,...)local v={...}local p,w=self,0;for o,x in pairs(v)do local y=p:FindFirstChild(x)if y then p=y;w=w+1 end end;if w==#v then return p end end;b.WaitForNext=function(self,...)local v={...}local p,w=self,0;for o,x in pairs(v)do local y=p:WaitForChild(x,5)if y then p=y;w=w+1 end end;if w==#v then return p end end;b.FindNextChildWhichIsA=function(self,...)local v={...}local p,w=self,0;for o,x in pairs(v)do local y=p:FindFirstChildWhichIsA(x)if y then p=y;w=w+1 end end;if w==#v then return p end end;b.FindNextChildOfClass=function(self,...)local v={...}local p,w=self,0;for o,x in pairs(v)do local y=p:FindFirstChildOfClass(x)if y then p=y;w=w+1 end end;if w==#v then return p end end;b.SetProperty=function(self,z,h)local A={table.unpack(getconnections(self.Changed)),table.unpack(getconnections(self:GetPropertyChangedSignal(z)))}for o,x in pairs(A)do x:Disable()end;self[z]=h;for o,x in pairs(A)do x:Enable()end end;b.GetParents=function(self)local B=self.Parent;local C={B}while true do if B==nil or B.Parent==nil then return C else B=B.Parent;table.insert(C,B)end end end;b.SetParent=function(self,D)local E={table.unpack(getconnections(D.ChildAdded)),table.unpack(getconnections(D.DescendantAdded))}for o,F in pairs(b.GetParents(self))do local A={table.unpack(getconnections(F.ChildRemoved)),table.unpack(getconnections(F.DescendantRemoving))}for o,x in pairs(A)do table.insert(E,x)end end;for o,F in pairs(b.GetParents(D))do local A={table.unpack(getconnections(F.ChildAdded)),table.unpack(getconnections(F.DescendantAdded))}for o,x in pairs(A)do table.insert(E,x)end end;for o,x in pairs(E)do x:Disable()end;self.Parent=D;for o,x in pairs(E)do x:Enable()end end;local G;G=hookmetamethod(game,"__namecall",newcclosure(function(self,...)local H=getnamecallmethod()if checkcaller()and b[H]then return b[H](self,...)end;return G(self,...)end))
